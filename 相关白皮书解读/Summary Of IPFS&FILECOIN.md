## IPFS设计分层

**1. 身份** - 管理节点身份生成和验证。

**2. 网络** - 管理与其他对等体的连接，使用各种底层网络协议。可配置的。

**3. 路由** - 维护信息以定位特定的对等体和对象。响应本地和远程查询。默认为DHT，但可更换。

**4. 交换** - 一种支持有效块分配的新型块交换协议（BitSwap）。模拟市场，弱化数据复制。贸易策略可替换。

**5. 对象** - 具有链接的内容寻址不可更改对象的Merkle DAG。用于表示任意数据结构，例如文件层次和通信系统。

**6. 文件** - 由Git启发的版本化文件系统层次结构。

**7. 命名** - 自我认证的可变名称系统。$针对特定文件，可以锁定唯一hash$

```
这些子系统不是独立的;
它们是集成在一起，互相利用各自的属性。
从下到上构建协议栈。
```



## IPFS 数据上传流程分析

1. 首次启动的时候，会通过配置文件中的bootstrap选项拿出来种子节点，建立网络连接~建立连接可能和传统的P2P不太一样，待确定：自己维护一张路由表？还是维护一个连接列表？~；` Bittorrent如何做的呢？`
2. 连接的时候，会通过身份层，做节点有效性验证；NodeID，自描述Hash值；两个值一致则对等节点允许接入;
3. 将文件按照上限256K字节打散成一个一个的block，计算每个block的hash，同时计算文件的merkel root hash；
4. 将3的hash存入DHT； DHT会在路由层被使用；DHT会在bitswap协议中，被全节点维护；
5. 到4步的时候，只是进行了本地存储，没有上传至IPFS公网；随后要进行pub操作；



## IPFS 数据下载流程分析

1. 如果该文件被PIN过，则直接从本地返回；否则会向对等节点发送block hash列表；
2. 对等节点通过DHT和路由层算法，找到每个block hash所在的节点，将文件返回来；
3. 本地节点在接收block文件的同时，也会不断的将block广播至其他对等节点；
4. 更新DHT；组装block文件，返回至用户端；



##  IPFS中核心技术点

1. 路由寻址，IPFS使用基于S / Kademlia和Coral的DSHT； ~可配~
2. 改进的torrent协议，Bitswap协议；
3. 扩展Git，增加了List对象结构；（Block，Tree，Commit）
4. 网络层支持多种传输协议SCTP、UTP等，支持NAT穿越；



## IPFS缺陷

1. 分布式节点治理没有考虑，filecoin的白皮书里也没有给出具体的治理升级方案； ~可以融合ontology-native治理合约、maidsafe和NKN治理模式，在这块做些探索？~
2. another



## Filecoin系统模型



![WX20180525-123022@2x](/Users/geeker/workspace/ChainBook/IPFS/PIC/WX20180525-123022@2x.png)

> 系统角色说明:
>
> DSN：分布式存储系统
>
> 矿工：矿工包括检索矿工和存储矿工；指系统中，提供存储服务或者检索服务的存储节点；
>
> 用户：向存储网络中提交存储和检索请求；
>
> 市场：市场进一步细分为检索市场和存储市场；是系统中的抽象角色，用于撮合交易；



## 用户行为分析

1. Put：客户将数据存储于Filecoin

   >- 客户通过Put协议向存储市场的订单簿提交投标订单。
   >- 当找到矿工的匹配报价订单的时候，客户会将数据发给矿工，并且双方签署交易订单将其提交到存储市场订单簿。
   >- 客户可以通过提交的订单来决定数据的物理副本数量。

   

2. Get：客户从Filecoin检索数据

   > - 客户端通过执行Get协议向检索市场订单簿提交投标订单。
   > - 当找到匹配的矿工报价订单后，客户会收到来自矿工的碎片。
   > - 当收到的时候，双方对交易订单进行签名提交到区块链来确认交易成功。



## 存储挖矿流程分析

1. 抵押：存储矿工向网络抵押存储

   > - 存储矿工通过在抵押交易中存放抵押品来保证向区块链提供存储。
   > - 如果矿工为他们所承诺提交存储的数据生成 **存储证明** ，抵押品就会返还给他们。
   > - 如果存储证明失败了，一定数量的抵押品就会损失。
   > - 他们设定价格并向市场订单簿提交报价订单，一旦抵押交易在区块链中出现，矿工就能在存储市场中
   > - 提供他们的存储。

   

2. 接收订单：存储矿工从存储市场获取存储请求

   > - 他们设定价格并通关过**Put.AddOrders**向市场订单簿提交报价订单。
   > - 一旦抵押交易出现在区块链中，矿工就能在存储市场中提供他们的存储

   

3. 匹配订单

   > - 该过程通过市场完成，一但矿工询价订单和用户报价订单匹配，客户会将他们待存储的数据发送给存储矿工；
   > - 数据接收完成后，矿工和客户签收订单，并将其提交到区块链；

   

4. 密封：存储矿工为未来的证明准备数据（时空证明，证明自己在某个时间段存了某写数据）

   > - 存储矿工的存储切分为扇区，每个扇区包括了分配给矿工的数据。
   > - 网络通过分配表来跟踪每个存储矿工的扇区。
   > - 当存储矿工的扇区填满了，这个扇区就被密封起来。

   

5. 证明：存储矿工证明他们正在存储所承诺的碎片

   > - 当存储矿工分配数据时，必须重复生成复制证明以保证他们正在存储数据
   > - 证明发布在区块链中，并由网络来验证。



## 检索挖矿流程分析

1. 匹配订单

   > - 市场根据检索矿工的询价订单，匹配用户的检索报价订单；
   > - 检索矿工收到市场发过来的检索订单；
   > - 检查订单是否有效；



2. 发送：检索矿工向客户发送数据碎片

   > - 一旦订单匹配，检索矿工就将数据发送给客户。
   > - 当数据被接收完成，矿工和客户就签署交易并提交到区块链。



## 存储市场行为分析

**Put订单：** 有三种类型的订单：出价订单，询价订单和交易订单。

存储矿工创建询价订单添加存储，客户创建出价订单请求存储，当双方对价格达成一致时，他们共同创建处理订单。订单的数据结构和订单参数的明确定义如图10所示。

**Put订单簿：** 存储市场的订单簿是目前有效和开放的询价，出价和 交易订单的集合。

> 订单簿是公开的，并且每个诚实的用户都有同样的订单簿视图。
>
> 在每个周期，如果新的订单交易出现在新的区块中那它将被添加到订单簿中。
>
> 如果订单被取消，取消或者结算，则会被删除，不会上链；



**存储市场协议分为两个阶段：订单匹配和结算**

订单匹配：客户端和存储矿工通过提交交易到区块链来将订单提交到订单簿。当订单匹配时，客户端发送数据碎片给存储矿工，双方签署交易并提交到订单簿。

结算： 存储矿工密封扇区，生成扇区所包含的碎片的存储证明，并将其定期提交到区块链；同时，其余的网络必须验证矿工生成的证明并修复可能的故障



## 检索市场行为分析

**获取订单** 检索市场中包含有三种类型的订单：客户端创建的出价单 Obid，检索矿工创建的询价单Oask，和存储矿工和客户端达成的交易订单Odeal。

**获取订单簿** 检索市场的订单簿是有效的和公开出价订单，询价订单和交易订单的集合。

与存储市场不同，每个用户有不同的订单簿视图，因为订单是在网络中传播的，每个矿工和客户端只会跟踪他们所感兴趣的订单。

**检索市场协议分为两个阶段：订单匹配和结算**

**订单匹配** 客户端和检索矿工通过广播将订单提交给订单簿。

>  当订单匹配的时候，客户端和检索矿工建立小额支付通道。

**结算** 检索矿工发送小部分的碎片给到客户端，然后对每个碎片客户端会向矿工发送收到的收据。

检索矿工向区块链出示收据从而获得奖励。



## Filecoin中的共识

`有用工作共识`，传统的POW共识，太傻；

**试图减少浪费**：理想情况下，大部分网络资源应该花费在有用的工作上。一些尝试是要求矿工使用更节能的解决方案。例如“空间挖矿”，要求矿工致力于磁盘空间而不是计算；

**共识过程分析：**

- 统计时空证明量，即每个节点已经提供的存储；
- 选举出一个leader集合；
- 从leader集合中选举出一个矿工出块；
- 其他节点验证区块，然后入链；
- 选举的权重，和时空证明量成正比； POS算法



## Filecoin中的智能合约

白皮书里聊聊数笔带过，没有亮点特色